Concise Python3 Notes  
                        by zcatt, Jan2018






*.主要章节
==================
.一些基本知识
*Python data model





*.一些基本知识
==================

.提示符
----------
interactive mode时， >>> 是命令提示符， ... 是续行提示符

.encode
----------
source code encoding的指定可以在文件中的第一行放置如下格式的内容。(含unix命令设置的，则格式是第二行。)
# -*- coding: encoding -*-

例如,
#!/usr/bin/env python3
# -*- coding: cp-1252 -*-


.comment
----------
以#开始到行尾


.基本运算
----------

/		float div
//      int div
%		remainder


.String
----------

'或"		成对使用圈定string内容。
'''或"""	成对使用，可以圈定多行string
\			string中转义符
[n]         下标， 0-based index。若是负数，则从右侧算起.
[n:m]       区间子string。 从n到m的子串，含n不含m。n或m的缺省分别表示从头开始或到尾结束。

				 +---+---+---+---+---+---+
				 | P | y | t | h | o | n |
				 +---+---+---+---+---+---+
				 0   1   2   3   4   5   6
				-6  -5  -4  -3  -2  -1

string是immutable，不能修改其元素字符.


.List
----------
方括号包围，逗号间隔的形式。
		>>> squares = [1, 4, 9, 16, 25]
		>>> squares
		[1, 4, 9, 16, 25]

支持下标操作。

		>>> squares[:]
		[1, 4, 9, 16, 25]

list是mutable。 +和append()可以追加。下标操作可以完成较复杂的任务。

		>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
		>>> letters
		['a', 'b', 'c', 'd', 'e', 'f', 'g']
		>>> letters[2:5] = ['C', 'D', 'E']
		>>> letters
		['a', 'b', 'C', 'D', 'E', 'f', 'g']
		>>> letters[:] = []
		>>> letters
		[]

一些built-in fuctions，len(), 

.基本语句
----------

if语句

	>>> x = int(input("Please enter an integer: "))
	Please enter an integer: 42
	>>> if x < 0:
	...     x = 0
	...     print('Negative changed to zero')
	... elif x == 0:
	...     print('Zero')
	... elif x == 1:
	...     print('Single')
	... else:
	...     print('More')
	...
	More

for语句
	>>> # Measure some strings:
	... words = ['cat', 'window', 'defenestrate']
	>>> for w in words:
	...     print(w, len(w))
	...
	cat 3
	window 6
	defenestrate 12

range(), 序列

	>>> for i in range(5):
	...     print(i)
	...
	0
	1
	2
	3
	4
	
	range(5, 10)
	   5 through 9

	range(0, 10, 3)
	   0, 3, 6, 9

	range(-10, -100, -30)
	  -10, -40, -70

break, continue, and else.    与C不同，else也可以用于loop语句，例如for
	>>> for n in range(2, 10):
	...     for x in range(2, n):
	...         if n % x == 0:
	...             print(n, 'equals', x, '*', n//x)
	...             break
	...     else:
	...         # loop fell through without finding a factor
	...         print(n, 'is a prime number')
	...
	2 is a prime number
	3 is a prime number
	4 equals 2 * 2
	5 is a prime number
	6 equals 2 * 3
	7 is a prime number
	8 equals 2 * 4
	9 equals 3 * 3

pass语句.  无实际语义，视作空语句.

定义函数. 函数体内的第一条语句如果是注释，则称作docstring.
	函数具有local symbol table.函数体内的变量名按照local symbol > global symbol > built-in symbol的优先顺序解释变量名.
	故直接对全局变量进行复制是错误的. python的参数调用使用"call by value"方式.
	函数名保存在当前symbol table中，标识为user-defined function.
	函数总是返回一个值。如果没有return语句，则返回None.

	>>> def fib(n):    # write Fibonacci series up to n
	...     """Print a Fibonacci series up to n."""
	...     a, b = 0, 1
	...     while a < n:
	...         print(a, end=' ')
	...         a, b = b, a+b
	...     print()
	...
	>>> # Now call the function we just defined:
	... fib(2000)
	0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
	
变长参数和默认参数的函数定义
	特别注意，默认值仅计算一次。

	def ask_ok(prompt, retries=4, reminder='Please try again!'):
		while True:
			ok = input(prompt)
			if ok in ('y', 'ye', 'yes'):
				return True
			if ok in ('n', 'no', 'nop', 'nope'):
				return False
			retries = retries - 1
			if retries < 0:
				raise ValueError('invalid user response')
			print(reminder)

	def f(a, L=[]):
		L.append(a)
		return L

	print(f(1))
	print(f(2))
	print(f(3))

	输出	
	[1]
	[1, 2]
	[1, 2, 3]

keyword argument，调用中keyword argument必须跟在positional argument的后面

	def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
		print("-- This parrot wouldn't", action, end=' ')
		print("if you put", voltage, "volts through it.")
		print("-- Lovely plumage, the", type)
		print("-- It's", state, "!")

	parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword

arbitary argument list. 一般varadic argument位于参数表的最后，或者其后仅能跟随keyword argument.

	>>> def concat(*args, sep="/"):
	...     return sep.join(args)
	...
	>>> concat("earth", "mars", "venus", sep=".")
	'earth.mars.venus'

unpacking argument lists, 可以使用*对argument list进行解包,使用**对dictionary进行解包

	>>> list(range(3, 6))            # normal call with separate arguments
	[3, 4, 5]
	>>> args = [3, 6]
	>>> list(range(*args))            # call with arguments unpacked from a list
	[3, 4, 5]


	>>> def parrot(voltage, state='a stiff', action='voom'):
	...     print("-- This parrot wouldn't", action, end=' ')
	...     print("if you put", voltage, "volts through it.", end=' ')
	...     print("E's", state, "!")
	...
	>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
	>>> parrot(**d)
	-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !


lambda expression

	>>> def make_incrementor(n):
	...     return lambda x: x + n
	...
	>>> f = make_incrementor(42)
	>>> f(0)
	42
	>>> f(1)
	43

coding style
	
.Data struct
----------

more on lists
	list.append(x)					a[len(a):] = [x]
	list.extend(iterable)			
	list.insert(i,x)				在i index位置插入
	list.pop([i])
	list.clear()
	list.index(x[,start[,end]])		返回x的index
	list.count(x)
	list.sort(key=None,reverse=False)	sort in place
	list.reverse()
	list.copy()						shallow copy

list comprehension. 方括号中表达式后跟for或if从句.
	squares = [x**2 for x in range(10)]

nested list comprehensions
	>>> [[row[i] for row in matrix] for i in range(4)]
	[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

del statement
	>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
	>>> del a[0]
	>>> a
	[1, 66.25, 333, 333, 1234.5]
	>>> del a[2:4]
	>>> a
	[1, 66.25, 1234.5]
	>>> del a[:]
	>>> a
	[]

	整个删除
	>>> del a

tuples and sequences. 
	A tuple consists of a number of values separated by commas. output tuples are always enclosed in parentheses. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking or indexing. Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list.
	0个或1个元素的tuple的构建
	>>> empty = ()
	>>> singleton = 'hello',    # <-- note trailing comma
	>>> len(empty)
	0
	>>> len(singleton)
	1
	>>> singleton
	('hello',)

sets
	A set is an unordered collection with no duplicate elements.Curly braces or the set() function can be used to create sets. Note: to create an empty set you have to use set(), not {}; the latter creates an empty dictionary.

	>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
	>>> 'orange' in basket                 # fast membership testing
	True
	>>> 'crabgrass' in basket
	False

	>>> a = set('abracadabra')
	>>> b = set('alacazam')
	>>> a                                  # unique letters in a
	{'a', 'r', 'b', 'c', 'd'}
	>>> a - b                              # letters in a but not in b
	{'r', 'd', 'b'}
	>>> a | b                              # letters in a or b or both
	{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
	>>> a & b                              # letters in both a and b
	{'a', 'c'}
	>>> a ^ b                              # letters in a or b but not both
	{'r', 'd', 'b', 'm', 'z', 'l'}


dictionaries.
	dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key.
	A pair of braces creates an empty dictionary: {}. 

	>>> tel = {'jack': 4098, 'sape': 4139}
	>>> tel['guido'] = 4127
	>>> tel
	{'sape': 4139, 'guido': 4127, 'jack': 4098}
	>>> tel['jack']
	4098
	>>> del tel['sape']
	>>> tel['irv'] = 4127
	>>> tel
	{'guido': 4127, 'irv': 4127, 'jack': 4098}
	>>> list(tel.keys())
	['irv', 'guido', 'jack']
	>>> sorted(tel.keys())
	['guido', 'irv', 'jack']
	>>> 'guido' in tel
	True
	>>> 'jack' not in tel
	False

	When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the items() method.

looping collections

	items() on dictionary
	>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
	>>> for k, v in knights.items():
	...     print(k, v)
	...
	gallahad the pure
	robin the brave

	enumerate() on sequence
	>>> for i, v in enumerate(['tic', 'tac', 'toe']):
	...     print(i, v)
	...
	0 tic
	1 tac
	2 toe

.Modules
----------

每个module都有自己的私有symbol table, 用于存储自己的全局变量。跨module访问时使用形式 modname.itemname.

import语句
	导入module的symbol table。

	>>>from fibo import fib,fib2
	or
	>>>from fibo import *					下划线(_)开头的symbol不会导入

sys.path
	搜寻module的路径是sys.path,其值依次取自当前运行脚本的路径，PYTHONPATH env, 

	>>> import sys
	>>> sys.path.append('/ufs/guido/lib/python')

	
cache
	为了提高载入效率，python会将module已编译的文件存放到__pychace__, 取名module.verion.pyc

dir()语句
	查找module定义的的names.
	built-in functions and variables are defined in module builtins.

package
	package的目录结构中必须放置__init__.py文件，python以此认定爱目录下包含packages.
	全称限定使用'.'间隔各package names和module name。
	使用import后可以省略packagenames以及module name限定。

	from sound.effects import echo
	echo.echofilter(input, output, delay=0.7, atten=4)

	from sound.effects.echo import echofilter
	echofilter(input, output, delay=0.7, atten=4)

importing * from package
	使用"from ... import *"时仅载入__init__.py中__all__定义的modules.

.Input and Output
----------

字串格式输出
	repr()
	str()

	>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
	>>> for name, phone in table.items():
	...     print('{0:10} ==> {1:10d}'.format(name, phone))
	...
	Jack       ==>       4098
	Dcab       ==>       7678
	Sjoerd     ==>       4127

	>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
	>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
	...       'Dcab: {0[Dcab]:d}'.format(table))
	Jack: 4098; Sjoerd: 4127; Dcab: 8637678

	>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
	>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
	Jack: 4098; Sjoerd: 4127; Dcab: 8637678

	Old string formatting
	>>> import math
	>>> print('The value of PI is approximately %5.3f.' % math.pi)
	The value of PI is approximately 3.142.

reading and writing files
	open(filename, mode)				r, w, r+, a
	f.close()
	with ... as ..
	f.read(size)						size<0 or ommit则读全部
	f.readline()
	list(f) or f.readlines()			read all lines
	f.write(string)
	f.tell()
	f.seek(offset, from_what)			0, beginning;1,current pos;2,end.

	
	>>> f = open('workfile', 'w')

	>>> with open('workfile') as f:
	...     read_data = f.read()
	>>> f.closed
	True

	>>> for line in f:
	...     print(line, end='')
	...
	This is the first line of the file.
	Second line of the file

saving structured data with json
	json.dumps(x)
	json.dump(x, f)				f is text file object.

.Errors and exceptions
----------

handling exceptions
	try...except...[else ...][finally...]
	exception.args
	exception.__str__


	>>> while True:
	...     try:
	...         x = int(input("Please enter a number: "))
	...         break
	...     except ValueError:
	...         print("Oops!  That was no valid number.  Try again...")
	...

	multiple exception sample
	... except (RuntimeError, TypeError, NameError):
	...     pass


	import sys

	try:
		f = open('myfile.txt')
		s = f.readline()
		i = int(s.strip())
	except OSError as err:
		print("OS error: {0}".format(err))
	except ValueError:
		print("Could not convert data to an integer.")
	except:
		print("Unexpected error:", sys.exc_info()[0])
		raise

	exception class sample,
	class B(Exception):
		pass

	class C(B):
		pass

	class D(C):
		pass

	for cls in [B, C, D]:
		try:
			raise cls()
		except D:
			print("D")
		except C:
			print("C")
		except B:
			print("B")

	else sample,
	for arg in sys.argv[1:]:
		try:
			f = open(arg, 'r')
		except OSError:
			print('cannot open', arg)
		else:
			print(arg, 'has', len(f.readlines()), 'lines')
			f.close()

raising exceptions
	raise

	>>> raise NameError('HiThere')
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	NameError: HiThere

user-defined exceptions
	derived from the Exception class, either directly or indirectly.	

.classes
----------
	允许继承多父母。允许动态创建和变更。all member functions are virtual.
	A namespace is a mapping from names to objects. 
	The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. 
	A scope is a textual region of a Python program where a namespace is directly accessible. Directly accessible here means that an unqualified reference to a name attempts to find the name in the namespace.

	nolocal, global			The global statement can be used to indicate that particular variables live in the global scope and should be rebound there; the nonlocal statement indicates that particular variables live in an enclosing scope and should be rebound there.

	Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class.

	__init__()


class definition syntax
	class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>

class objects
instance objects

method objects	
	Often, the first argument of a method is called self.

class and instance variables
	instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:

	class Dog:
		kind = 'canine'         # class variable shared by all instances
		def __init__(self, name):
			self.name = name    # instance variable unique to each instance

inheritance
	class DerivedClassName(Base1[,Base2...]):
		<statement-1>
		.
		.
		.
		<statement-N>

	isinstance()		check an instance type
	issubclass()		check class inheritance

private variables
	a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API.
	name mangling. Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped.

odds and ends
	m.__self__ is the instance object with the method m().
	m.__func__ is the function object corresponding to the method.

	class Employee:
		pass

	john = Employee()  # Create an empty employee record

	# Fill the fields of the record
	john.name = 'John Doe'
	john.dept = 'computer lab'
	john.salary = 1000

iterators
	the for statement calls iter() on the container object. The function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time.
	
	若支持iterator，则需定义__iter__()和__next__()方法

	class Reverse:
		"""Iterator for looping over a sequence backwards."""
		def __init__(self, data):
			self.data = data
			self.index = len(data)

		def __iter__(self):
			return self

		def __next__(self):
			if self.index == 0:
				raise StopIteration
			self.index = self.index - 1
			return self.data[self.index]


generators
	Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed).

	def reverse(data):
		for index in range(len(data)-1, -1, -1):
			yield data[index]

.standard library
----------

os
	import os
	shutil

glob		file wildcards
	import glob

	>>> import glob
	>>> glob.glob('*.py')
	['primes.py', 'random.py', 'quote.py']

cmd line argument
	sys.argv

	>>> import sys
	>>> print(sys.argv)
	['demo.py', 'one', 'two', 'three']

Error Output Redirection and Program Termination
	sys.stdin, sys.stdout, sys.stderr
	sys.exit()

String Pattern Matching

	>>> import re
	>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
	['foot', 'fell', 'fastest']
	>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
	'cat in the hat'

Mathematics

	>>> import math
	>>> math.cos(math.pi / 4)
	0.70710678118654757
	>>> math.log(1024, 2)
	10.0

	>>> import random
	>>> random.choice(['apple', 'pear', 'banana'])
	'apple'
	>>> random.sample(range(100), 10)   # sampling without replacement
	[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
	>>> random.random()    # random float
	0.17970987693706186
	>>> random.randrange(6)    # random integer chosen from range(6)
	4

	>>> import statistics
	>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
	>>> statistics.mean(data)
	1.6071428571428572
	>>> statistics.median(data)
	1.25
	>>> statistics.variance(data)
	1.3720238095238095

Internet Access

	>>> from urllib.request import urlopen
	>>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
	...     for line in response:
	...         line = line.decode('utf-8')  # Decoding the binary data to text.
	...         if 'EST' in line or 'EDT' in line:  # look for Eastern Time
	...             print(line)

	<BR>Nov. 25, 09:43:32 PM EST

	>>> import smtplib
	>>> server = smtplib.SMTP('localhost')
	>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
	... """To: jcaesar@example.org
	... From: soothsayer@example.org
	...
	... Beware the Ides of March.
	... """)
	>>> server.quit()

Date and Time

	>>> # dates are easily constructed and formatted
	>>> from datetime import date
	>>> now = date.today()
	>>> now
	datetime.date(2003, 12, 2)
	>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
	'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

	>>> # dates support calendar arithmetic
	>>> birthday = date(1964, 7, 31)
	>>> age = now - birthday
	>>> age.days
	14368

data compression

	>>> import zlib
	>>> s = b'witch which has which witches wrist watch'
	>>> len(s)
	41
	>>> t = zlib.compress(s)
	>>> len(t)
	37
	>>> zlib.decompress(t)
	b'witch which has which witches wrist watch'
	>>> zlib.crc32(s)
	226805979

Performance Measurement

	>>> from timeit import Timer
	>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
	0.57535828626024577
	>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
	0.54962537085770791

Logging

	import logging
	logging.debug('Debugging information')
	logging.info('Informational message')
	logging.warning('Warning:config file %s not found', 'server.conf')
	logging.error('Error occurred')
	logging.critical('Critical error -- shutting down')


.
----------
.
----------


*.Python data model
==================

.Objects, values and types
----------
object是python对数据的抽象。数据在python中用object以及object之间的关系来表示。
object有一个id, 一个type和一个value。
id自创建后就不变更。'is'比较的是object之间的id. id()返回的是id的整数表示。 
type规定了支持的操作和取值范围，object's type是unchangeable， type()返回object's type.
value若可变，则称作mutable，否则称作immutable.
python使用garbage-collected销毁object。
containers是指包含到其它objects引用的object.例如 tuple, list and dictionary.

.Standard type hierarchy
----------
None					"None"
NotImplemented			"NotImplemented"
Ellipsis,				"..." or "Ellipsis"
numbers.number			immutable
	numbers.Integral
		Integers,		"int"
		Booleans,		"False" or "True"
	numbers.Real		"float"
	numbers.Complex		"complex"
Sequences				Finite ordered sets indexed by none-negative numbers. 
						len()
						0....n-1
						a[i:j] selects all items with index k (i<=k<j)
						a[i:j:k] selects all items with index x=i+n*k, where n>=0 && (i<= x <j)
						sequence可以按照mutability进行分类。
	immutable sequences 其元素object是immutable。
		Strings
		Tuples
		Bytes
	mutable sequences	中括号包围，逗号间隔.
		Lists			中括号包围，逗号间隔.
		Byte Arrays		由bytearray()创建.


Set types				unordered, finite sets of unique, immutable objects. they cannot be indexed by any subscript. iterable. 
	sets				mutable set. created by "set()".
	Frozen sets			immutable set. Created by "frozenset()". hashable.

Mappings				finite sets of objects indexed by arbitary index sets.
	Dictionaries		mutable. created by "{...}"。 keys are immutable.

Callable types			support function call operation.
	User-defined funcitons 		created by a function definition.
								special attributes,
									__doc__, doc string or None. Not inherited by subclass.
									__name__, function name
									__qualname__, qualified function name.	
									__module__, module name 
									__defaults__, a tuple containing default argument values. or None.
									__code__,  code object representing the compiled function body.
									__globals__,  a ref to dictionary that holds the functions's global variables.
									__dict__, the namespace supporting arbitrary function attributes.
									__closure__, None or a tuple of cells that contain bindings for the function's free variables.
									__annotations__, a dict containing annotations of parameters.
									__kwdefaults__, a dict containing defaults for keyword-only parameters.
	Instance methods				An instance method object combines a class, a class instance and any callable object(normally a user-defined function).
									__self__ is the class instance obj.
									__func__ is the function obj
									__doc__ is the method's documentation.
									__name__
									__module__
									When an instance method object is called, the underlying function (__func__) is called, inserting the class instance (__self__) in front of the argument list.   For instance, when C is a class which contains a definition for a function f(), and x is an instance of C, calling x.f(1) is equivalent to calling C.f(x, 1).
									When an instance method object is derived from a class method object, the “class instance” stored in __self__ will actually be the class itself, so that calling either x.f(1) or C.f(1) is equivalent to calling f(C,1) where f is the underlying function.
	Generator functions 			使用yield语句的function or method叫做a generator function.
	Coroutine functions 			使用async def的function or method称作a coroutine function. 它总是返回 a coroutine object， 其中包含了await expression 或 async with和async for语句。
	Built-in functions 
	Built-in methods
	Classes 						callable. Act as factories for new instances of themeselves.
									__new__()
									__init__()
	Class instances					can be made callable by defining a __call__ method in their class.

Modules								A basic organizational unit of Python code. Created either by teh import statement or by calling function such as importlib.import_module() and build-in __import__().
									A module object has a namespace, __dict__ is read-only dictionary object. Attribute assignment updates the module's namespace dictionary, e.g., m.x=1 is equivalent to m.__dict__["x"] = 1.
Custom classes 						Created by class definitions. A class has a namespace, __dict__. Class method 的__self__是class obj.
									special attributes:
									__name__, __module__, __dict__, __bases__.
Class instances						created by calling a class object.

I/O objects(file obj)				represents an open file.

Internal types 						used internally by the interpreter are exposed to the user.
	Code objects 					represent byte-compiled executable python code, or bytecode.
									special read-only attributes:
									co_name
									co_argcount
									co_nlocals
									co_varnames
									co_cellvars
									co_freevars
									co_code
									co_consts
									co_names
									co_filename
									co_firstlineno
									co_lnotab
									co_stacksize
									co_flags
	Frame objects 					represent execution frames.
	Traceback objects
	Slice objects
	Static method objects
	Class method objects


.Special method names
----------

class 的一些功能要求定义一些特定方法名的方法。

object.__new__(cls[,...])			create a new instance of class. if it return an instanc of class successfully, the __init__() will be called. if no instance is returned, __init__() will not be called.
object.__init__(self[,...])			called after the instance has been created, but before it is returned to the caller.
object.__del__(self)				called when to be destroyed.
object.__repr__(self)				the "official" string representation of an object.
object.__str__(self)				the "informal" or nicely printable string representation of an object.
object.__bytes__(self)				the byte-string representation of an obj.
object.__format__(self, format_spec)	the "formatted"string representation.
object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)

object.__hash__(self)
object.__bool__(self)

.Customizing attribute access
----------
对象属性的访问顺序：  实例属性, then 类属性, then 父类属性, then __getattr__()方法.


object.__getattr__(self, name)			Called when an attribute lookup has not found the attribute in the usual places.
object.__getattribute__(self,name)
object.__setattr__(self,name, value)
object.__delattr__(self,name)
object.__dir__(self)					called when dir() is called on the object.

Implementing Descriptors				descriptor(描述符)类是指实现了__get__(),__set__(),和__delete__()方法的类。 默认的attribute access顺序是object dictionary, class dictionary，例如a.x的查找顺序是a.__dict__['x']，then type(a).__dict__['x']. 
										但对于descriptor， 查找顺序则取决于descriptor以及调用的方式。
										Direct call,  		等价于x.__get__(a)
										Instance Binding,  	若x绑定到an object instance, a.x等价于type(a).__dict__['x'].__get__(a.type(a))
										class binding, 		A.x等价于A.__dict__['x'].__get__(None,A)
										Super Binding, 		if a is an instance of super,  see doc.
	object.__get__(self, instance, owner)
	object.__set__(self, instance, value)
	object.__delete__(self, instance)

__slots__								__slots__ reserves space for the declared variables and prevents the automatic creation of __dict__ and __weakref__ for each instance.

.Customizing class creation
----------
类定义时使用metaclass关键字，这样可以定制class creation process.
	class Meta(type):
		pass

	class MyClass(metaclass=Meta):
		pass

	class MySubclass(MyClass):
		pass
类定义的执行顺序，
	1.确定metaclass
	2.准备class namespace
	3.执行class body
	4.创建class object.

.Customizing instance and subclass checks
----------

.Emulating callable objects
----------

.Emulating container types
----------

.Emulating numeric types
----------

.With statement context managers
----------

.Special method lookup
----------

.Coroutines
----------

Awaitable objects
Coroutine objects
Asynchronous iterators
Asynchronous context managers



*.ref
==================
.python3 doc 

